<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebRTC 井字棋</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Microsoft JhengHei", sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      margin: 0;
      background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      color: #333;
      padding: 20px;
      box-sizing: border-box;
    }
    .container {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.15);
      padding: 30px;
      width: 100%;
      max-width: 600px;
      text-align: center;
    }
    h1 {
      color: #2c3e50;
      margin-bottom: 25px;
      font-size: 32px;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
    }
    .mode-group {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-bottom: 25px;
      justify-content: center;
    }
    .mode-btn {
      padding: 12px 24px;
      border: 2px solid #3498db;
      border-radius: 8px;
      background: #fff;
      cursor: pointer;
      transition: all 0.3s;
      font-size: 16px;
      font-weight: 600;
      color: #3498db;
      min-width: 120px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
    }
    .mode-btn:hover {
      background: #3498db;
      color: #fff;
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.1);
    }
    .mode-btn.active {
      border-color: #2ecc71;
      background: #2ecc71;
      color: #fff;
    }
    .board {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      gap: 6px;
      background: #34495e;
      border-radius: 10px;
      padding: 8px;
      margin: 0 auto 25px;
      max-width: 400px;
      aspect-ratio: 1/1;
    }
    .cell {
      background: #ecf0f1;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: clamp(40px, 10vw, 56px);
      color: #333;
      border-radius: 6px;
      touch-action: manipulation;
      transition: all 0.2s;
      box-shadow: inset 0 0 10px rgba(0,0,0,0.05);
    }
    .cell:hover {
      background: #d5dbdb;
      transform: scale(0.98);
    }
    .cell.X { 
      color: #e74c3c; 
      text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .cell.O { 
      color: #3498db; 
      text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }
    .status {
      font-size: 22px;
      color: #2c3e50;
      margin-bottom: 20px;
      min-height: 30px;
      font-weight: 600;
    }
    .status.win {
      color: #27ae60;
      font-size: 26px;
      animation: pulse 1s infinite;
    }
    .status.draw {
      color: #f39c12;
      font-size: 26px;
    }
    button {
      padding: 14px 32px;
      font-size: 18px;
      background: #2ecc71;
      color: #fff;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s;
      font-weight: 600;
      margin: 5px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    }
    button:hover {
      background: #27ae60;
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
    }
    button:active {
      transform: translateY(0);
    }
    button.secondary {
      background: #3498db;
    }
    button.secondary:hover {
      background: #2980b9;
    }
    .connection-panel {
      background: #f8f9fa;
      border-radius: 10px;
      padding: 20px;
      margin: 20px 0;
      width: 100%;
      box-shadow: 0 4px 8px rgba(0,0,0,0.05);
    }
    .connection-status {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 15px;
    }
    .status-indicator {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      margin-right: 10px;
      background: #e74c3c;
    }
    .status-indicator.connecting {
      background: #f39c12;
      animation: pulse 1s infinite;
    }
    .status-indicator.connected {
      background: #2ecc71;
    }
    .connection-controls {
      display: flex;
      justify-content: center;
      gap: 15px;
      flex-wrap: wrap;
    }
    input, textarea {
      padding: 12px;
      border: 2px solid #ddd;
      border-radius: 8px;
      font-size: 16px;
      width: 100%;
      max-width: 300px;
      margin: 10px 0;
      box-sizing: border-box;
      font-family: inherit;
    }
    textarea {
      height: 80px;
      resize: vertical;
    }
    .instructions {
      background: #f1f2f6;
      border-left: 4px solid #3498db;
      padding: 15px;
      margin: 20px 0;
      text-align: left;
      border-radius: 0 8px 8px 0;
      font-size: 14px;
    }
    .player-indicator {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 20px;
    }
    .player {
      padding: 10px 20px;
      border-radius: 8px;
      font-weight: bold;
      background: #ecf0f1;
      transition: all 0.3s;
    }
    .player.active {
      background: #3498db;
      color: white;
      box-shadow: 0 4px 8px rgba(52, 152, 219, 0.3);
    }
    .player.X.active {
      background: #e74c3c;
      box-shadow: 0 4px 8px rgba(231, 76, 60, 0.3);
    }
    .qrcode-container {
      margin: 15px auto;
      text-align: center;
    }
    .remote-controls {
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
    }
    .copy-btn {
      background: #3498db;
      padding: 10px 15px;
      font-size: 14px;
    }
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    @media (max-width: 500px) {
      .container {
        padding: 20px;
      }
      h1 {
        font-size: 28px;
      }
      .board {
        max-width: 300px;
      }
      .cell {
        font-size: 36px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>WebRTC 井字棋</h1>
    
    <div class="mode-group">
      <button class="mode-btn active" data-mode="hotseat">本地雙人</button>
      <button class="mode-btn" data-mode="pve">單人模式</button>
      <button class="mode-btn" data-mode="lan">局域網對戰</button>
    </div>
    
    <div class="player-indicator">
      <div class="player X">玩家 X</div>
      <div class="player O">玩家 O</div>
    </div>
    
    <div class="board" id="board"></div>
    
    <div class="status" id="status">玩家 X 回合</div>
    
    <div class="connection-panel" id="connectionPanel" style="display: none;">
      <div class="connection-box">
        <h3>WebRTC 連接</h3>
        <div class="connection-status">
          <div class="status-indicator" id="statusIndicator"></div>
          <span id="connectionStatus">未連接</span>
        </div>
        
        <div id="hostControls">
          <button id="createConnection" class="secondary">創建連接</button>
          <div class="instructions">
            <strong>主機操作步驟：</strong>
            <ol>
              <li>點擊"創建連接"按鈕</li>
              <li>將二維碼分享給對方掃描 <strong>或</strong></li>
              <li>複製下方連接信息發送給對方</li>
            </ol>
          </div>
          <div class="qrcode-container" id="qrcode"></div>
          <p>連接信息：</p>
          <textarea id="connectionData" readonly placeholder="創建連接後將顯示信息"></textarea>
          <button class="copy-btn" onclick="copyConnectionData()">複製信息</button>
        </div>
        
        <div id="guestControls" style="display: none;">
          <div class="instructions">
            <strong>客戶端操作步驟：</strong>
            <ol>
              <li>在主機創建連接後</li>
              <li>輸入主機分享的連接信息</li>
              <li>點擊"連接"按鈕</li>
              <li>或使用"掃描QR碼"功能</li>
            </ol>
          </div>
          <textarea id="remoteData" placeholder="請輸入主機分享的連接信息"></textarea>
          <div class="remote-controls">
            <button id="connectToHost" class="secondary">連接</button>
            <button id="scanQR" class="secondary">掃描QR碼</button>
          </div>
        </div>
      </div>
    </div>
    
    <button id="reset">重新開始</button>
  </div>

  <!-- 引入 QRCode 生成库 -->
  <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.1/build/qrcode.min.js"></script>
  <!-- 引入 WebRTC 库 -->
  <script src="https://cdn.jsdelivr.net/npm/simple-peer@9.11.1/simplepeer.min.js"></script>

  <script>
    // 游戏状态管理
    const game = {
      board: Array(9).fill(null),
      currentPlayer: "X",
      isGameOver: false,
      mode: "hotseat",
      peer: null,
      isHost: false,
      playerRole: "X",
      dataChannel: null,

      // 初始化游戏
      init() {
        this.render();
        this.bindEvents();
        this.updatePlayerIndicator();
        this.initWebRTC();
      },

      // 渲染棋盘
      render() {
        const boardEl = document.getElementById("board");
        boardEl.innerHTML = "";
        
        this.board.forEach((cell, index) => {
          const cellEl = document.createElement("div");
          cellEl.className = `cell ${cell === "X" ? "X" : cell === "O" ? "O" : ""}`;
          cellEl.dataset.index = index;
          cellEl.textContent = cell || "";
          
          // 绑定点击事件
          if (!this.isGameOver && 
              (this.mode === "hotseat" || 
               (this.mode === "pve" && this.currentPlayer === "X") ||
               (this.mode === "lan" && this.currentPlayer === this.playerRole))
          ) {
            cellEl.addEventListener("click", (e) => this.handlePlayerMove(e, index));
          }
          
          boardEl.appendChild(cellEl);
        });
        
        // 更新状态显示
        const statusEl = document.getElementById("status");
        statusEl.className = "status";
        
        if (this.isGameOver) {
          const winner = this.getWinner();
          if (winner) {
            statusEl.textContent = `玩家 ${winner} 獲勝！`;
            statusEl.classList.add("win");
          } else {
            statusEl.textContent = "平局！";
            statusEl.classList.add("draw");
          }
        } else {
          statusEl.textContent = `玩家 ${this.currentPlayer} 回合`;
        }
      },
      
      // 更新玩家指示器
      updatePlayerIndicator() {
        document.querySelectorAll(".player").forEach(playerEl => {
          playerEl.classList.remove("active");
          if (playerEl.textContent.includes(this.currentPlayer)) {
            playerEl.classList.add("active");
          }
        });
      },

      // 处理玩家落子
      handlePlayerMove(e, index) {
        // 防御：已落子或游戏结束则返回
        if (this.board[index] !== null || this.isGameOver) return;
        
        // 落子
        this.board[index] = this.currentPlayer;
        
        // 局域网模式下发送移动信息
        if (this.mode === "lan" && this.dataChannel && this.dataChannel.readyState === "open") {
          this.sendNetworkMessage({
            type: "move",
            index: index,
            player: this.currentPlayer
          });
        }
        
        this.render();
        this.updatePlayerIndicator();
        
        // 检查游戏状态
        if (this.checkWin(this.currentPlayer)) {
          this.isGameOver = true;
          this.render();
          return;
        }
        
        if (this.checkDraw()) {
          this.isGameOver = true;
          this.render();
          return;
        }
        
        // 切换回合（模式区分）
        if (this.mode === "hotseat" || this.mode === "lan") {
          this.currentPlayer = this.currentPlayer === "X" ? "O" : "X";
          this.updatePlayerIndicator();
        } else if (this.mode === "pve") {
          // 单人模式：切换到 AI 回合
          this.currentPlayer = "O";
          this.updatePlayerIndicator();
          setTimeout(() => this.aiMove(), 500);
        }
      },

      // AI 落子逻辑
      aiMove() {
        if (this.isGameOver) return;
        
        // 策略1：AI 尝试获胜
        const winPos = this.findWinOrBlock("O");
        if (winPos !== -1) {
          this.board[winPos] = "O";
          this.render();
          this.checkGameEnd("O");
          return;
        }
        
        // 策略2：拦截玩家获胜
        const blockPos = this.findWinOrBlock("X");
        if (blockPos !== -1) {
          this.board[blockPos] = "O";
          this.render();
          this.checkGameEnd("O");
          return;
        }
        
        // 策略3：优先中心
        if (this.board[4] === null) {
          this.board[4] = "O";
          this.render();
          this.checkGameEnd("O");
          return;
        }
        
        // 策略4：优先角落
        const corners = [0, 2, 6, 8].filter(i => this.board[i] === null);
        if (corners.length > 0) {
          const corner = corners[Math.floor(Math.random() * corners.length)];
          this.board[corner] = "O";
          this.render();
          this.checkGameEnd("O");
          return;
        }
        
        // 策略5：随机边缘
        const edges = [1, 3, 5, 7].filter(i => this.board[i] === null);
        if (edges.length > 0) {
          const edge = edges[Math.floor(Math.random() * edges.length)];
          this.board[edge] = "O";
          this.render();
          this.checkGameEnd("O");
        }
      },

      // 检查游戏结束（AI落子后调用）
      checkGameEnd(aiPlayer) {
        if (this.checkWin(aiPlayer)) {
          this.isGameOver = true;
          this.render();
        } else if (this.checkDraw()) {
          this.isGameOver = true;
          this.render();
        } else {
          // 切回玩家X回合
          this.currentPlayer = "X";
          this.updatePlayerIndicator();
          this.render();
        }
      },

      // 检查胜负
      checkWin(player) {
        const winPatterns = [
          [0,1,2], [3,4,5], [6,7,8],
          [0,3,6], [1,4,7], [2,5,8],
          [0,4,8], [2,4,6]
        ];
        return winPatterns.some(pattern => 
          pattern.every(index => this.board[index] === player)
        );
      },

      // 检查平局
      checkDraw() {
        return this.board.every(cell => cell !== null);
      },

      // 寻找获胜或拦截位置
      findWinOrBlock(player) {
        const winPatterns = [
          [0,1,2], [3,4,5], [6,7,8],
          [0,3,6], [1,4,7], [2,5,8],
          [0,4,8], [2,4,6]
        ];
        
        for (const pattern of winPatterns) {
          const [a, b, c] = pattern;
          if (
            this.board[a] === player && 
            this.board[b] === player && 
            this.board[c] === null
          ) return c;
          if (
            this.board[a] === player && 
            this.board[c] === player && 
            this.board[b] === null
          ) return b;
          if (
            this.board[b] === player && 
            this.board[c] === player && 
            this.board[a] === null
          ) return a;
        }
        return -1;
      },

      // 获取获胜者
      getWinner() {
        if (this.checkWin("X")) return "X";
        if (this.checkWin("O")) return "O";
        return null;
      },

      // 重置游戏
      reset() {
        this.board = Array(9).fill(null);
        this.currentPlayer = "X";
        this.isGameOver = false;
        
        // 局域网模式下发送重置信息
        if (this.mode === "lan" && this.dataChannel && this.dataChannel.readyState === "open") {
          this.sendNetworkMessage({ type: "reset" });
          if (this.isHost) {
            this.sendNetworkMessage({ 
              type: "role",
              role: this.playerRole
            });
          }
        }
        
        this.updatePlayerIndicator();
        this.render();
      },

      // 切换模式
      switchMode(mode) {
        this.mode = mode;
        document.querySelectorAll(".mode-btn").forEach(btn => {
          btn.classList.remove("active");
          if (btn.dataset.mode === mode) {
            btn.classList.add("active");
          }
        });
        
        // 显示/隐藏局域网控制面板
        const connectionPanel = document.getElementById("connectionPanel");
        if (mode === "lan") {
          connectionPanel.style.display = "block";
          this.resetConnectionUI();
        } else {
          connectionPanel.style.display = "none";
          if (this.peer) {
            this.peer.destroy();
            this.peer = null;
            this.dataChannel = null;
          }
          this.updateConnectionStatus("未連接", "disconnected");
        }
        
        this.reset();
      },
      
      // 初始化WebRTC
      initWebRTC() {
        document.getElementById('createConnection').addEventListener('click', () => {
          this.createHostConnection();
        });
        
        document.getElementById('connectToHost').addEventListener('click', () => {
          this.connectAsGuest();
        });
        
        document.getElementById('scanQR').addEventListener('click', () => {
          alert('請使用手機相機掃描主機分享的二維碼');
        });
      },
      
      // 重置连接UI
      resetConnectionUI() {
        document.getElementById('hostControls').style.display = 'none';
        document.getElementById('guestControls').style.display = 'none';
        document.getElementById('connectionData').value = '';
        document.getElementById('remoteData').value = '';
        document.getElementById('qrcode').innerHTML = '';
      },
      
      // 主機創建連接
      createHostConnection() {
        this.isHost = true;
        this.playerRole = "X";
        this.resetConnectionUI();
        
        // 創建新的RTCPeerConnection
        this.peer = new SimplePeer({
          initiator: true,
          trickle: false,
          config: {
            iceServers: [
              { urls: 'stun:stun.l.google.com:19302' },
              { urls: 'stun:global.stun.twilio.com:3478?transport=udp' }
            ]
          }
        });
        
        this.setupPeerEvents();
        document.getElementById('hostControls').style.display = 'block';
        this.updateConnectionStatus("等待連接...", "connecting");
      },
      
      // 客戶端連接
      connectAsGuest() {
        this.isHost = false;
        this.playerRole = "O";
        
        try {
          const remoteData = document.getElementById('remoteData').value;
          if (!remoteData) {
            alert('請輸入有效的連接信息');
            return;
          }
          
          this.peer = new SimplePeer({
            initiator: false,
            trickle: false,
            config: {
              iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:global.stun.twilio.com:3478?transport=udp' }
              ]
            }
          });
          
          this.setupPeerEvents();
          this.peer.signal(JSON.parse(remoteData));
          this.updateConnectionStatus("正在連接...", "connecting");
        } catch (e) {
          alert('連接信息格式錯誤: ' + e.message);
        }
      },
      
      // 設置 WebRTC 事件監聽
      setupPeerEvents() {
        this.peer.on('signal', data => {
          console.log('Signal data:', data);
          const dataStr = JSON.stringify(data);
          document.getElementById('connectionData').value = dataStr;
          
          // 生成 QRCode
          QRCode.toCanvas(document.getElementById('qrcode'), dataStr, {
            width: 150,
            margin: 1,
            color: {
              dark: '#000',
              light: '#fff'
            }
          }, error => {
            if (error) console.error(error);
          });
        });
        
        this.peer.on('connect', () => {
          console.log('WebRTC 連接成功');
          this.dataChannel = this.peer;
          this.updateConnectionStatus("已連接", "connected");
          this.reset();
          
          if (this.isHost) {
            this.sendNetworkMessage({ 
              type: "role",
              role: this.playerRole
            });
          }
        });
        
        this.peer.on('data', data => {
          try {
            const msg = JSON.parse(data);
            this.handleNetworkMessage(msg);
          } catch (e) {
            console.error('數據解析錯誤:', e);
          }
        });
        
        this.peer.on('close', () => {
          console.log('WebRTC 連接關閉');
          this.updateConnectionStatus("連接已關閉", "disconnected");
          this.dataChannel = null;
        });
        
        this.peer.on('error', err => {
          console.error('WebRTC 錯誤:', err);
          alert('連接錯誤: ' + err.message);
          this.updateConnectionStatus("連接錯誤", "disconnected");
        });
      },
      
      // 處理網絡消息
      handleNetworkMessage(msg) {
        console.log("收到網絡消息:", msg);
        switch(msg.type) {
          case "move":
            this.board[msg.index] = msg.player;
            this.currentPlayer = this.currentPlayer === "X" ? "O" : "X";
            this.render();
            this.updatePlayerIndicator();
            break;
          case "reset":
            this.reset();
            break;
          case "role":
            this.playerRole = msg.role;
            break;
        }
      },
      
      // 發送網絡消息
      sendNetworkMessage(msg) {
        if (this.dataChannel && this.dataChannel.connected) {
          try {
            this.dataChannel.send(JSON.stringify(msg));
          } catch (e) {
            console.error('發送消息失敗:', e);
          }
        }
      },
      
      // 更新连接状态
      updateConnectionStatus(text, status) {
        document.getElementById("connectionStatus").textContent = text;
        const indicator = document.getElementById("statusIndicator");
        indicator.className = "status-indicator";
        
        if (status === "connecting") {
          indicator.classList.add("connecting");
        } else if (status === "connected") {
          indicator.classList.add("connected");
        }
        
        // 显示/隐藏客户端控制面板
        if (status === "connected") {
          document.getElementById('hostControls').style.display = this.isHost ? 'block' : 'none';
          document.getElementById('guestControls').style.display = this.isHost ? 'none' : 'block';
        }
      },

      // 绑定事件
      bindEvents() {
        document.getElementById("reset").addEventListener("click", () => this.reset());
        
        document.querySelectorAll(".mode-btn").forEach(btn => {
          btn.addEventListener("click", () => this.switchMode(btn.dataset.mode));
        });
      }
    };
    
    // 複製連接信息
    function copyConnectionData() {
      const textarea = document.getElementById('connectionData');
      textarea.select();
      document.execCommand('copy');
      alert('已複製連接信息');
    }
    
    // 初始化
    document.addEventListener('DOMContentLoaded', () => {
      game.init();
    });
  </script>
</body>
</html>