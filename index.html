<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>新一代 WebRTC 井字棋</title>
  <style>
    :root {
      --primary: #4a6bff;
      --secondary: #ff6b6b;
      --dark: #1a1a2e;
      --light: #f8f9fa;
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      font-family: 'Segoe UI', system-ui, sans-serif;
    }
    
    body {
      background: linear-gradient(135deg, var(--dark), #16213e);
      color: var(--light);
      min-height: 100vh;
      display: grid;
      place-items: center;
      padding: 1rem;
    }
    
    .game-container {
      width: 100%;
      max-width: 600px;
      background: rgba(255, 255, 255, 0.05);
      backdrop-filter: blur(10px);
      border-radius: 1rem;
      padding: 2rem;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    h1 {
      text-align: center;
      margin-bottom: 1.5rem;
      background: linear-gradient(90deg, var(--primary), var(--secondary));
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      font-size: 2.5rem;
    }
    
    .game-board {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 0.75rem;
      margin: 2rem 0;
    }
    
    .cell {
      aspect-ratio: 1;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 0.5rem;
      display: grid;
      place-items: center;
      font-size: 3.5rem;
      cursor: pointer;
      transition: all 0.2s ease;
      border: 2px solid transparent;
    }
    
    .cell:hover {
      background: rgba(255, 255, 255, 0.1);
      transform: scale(1.03);
    }
    
    .cell.X {
      color: var(--primary);
      text-shadow: 0 0 15px rgba(74, 107, 255, 0.7);
    }
    
    .cell.O {
      color: var(--secondary);
      text-shadow: 0 0 15px rgba(255, 107, 107, 0.7);
    }
    
    .connection-panel {
      background: rgba(0, 0, 0, 0.2);
      padding: 1.5rem;
      border-radius: 0.75rem;
      margin-top: 1.5rem;
    }
    
    .connection-status {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 1rem;
    }
    
    .status-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #f44336;
    }
    
    .status-indicator.connected {
      background: #4caf50;
      animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    
    .room-controls {
      display: flex;
      gap: 0.75rem;
      margin-bottom: 1rem;
    }
    
    input, button {
      padding: 0.75rem 1rem;
      border-radius: 0.5rem;
      border: none;
      font-size: 1rem;
    }
    
    input {
      flex: 1;
      background: rgba(0, 0, 0, 0.3);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    button {
      cursor: pointer;
      font-weight: 600;
      transition: all 0.2s;
    }
    
    button:hover {
      transform: translateY(-2px);
    }
    
    .btn-primary {
      background: var(--primary);
      color: white;
    }
    
    .btn-secondary {
      background: var(--secondary);
      color: white;
    }
    
    @media (max-width: 600px) {
      .game-container {
        padding: 1rem;
      }
      
      .cell {
        font-size: 2.5rem;
      }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <h1>WebRTC 井字棋</h1>
    
    <div class="game-board" id="board">
      <div class="cell" data-index="0"></div>
      <div class="cell" data-index="1"></div>
      <div class="cell" data-index="2"></div>
      <div class="cell" data-index="3"></div>
      <div class="cell" data-index="4"></div>
      <div class="cell" data-index="5"></div>
      <div class="cell" data-index="6"></div>
      <div class="cell" data-index="7"></div>
      <div class="cell" data-index="8"></div>
    </div>
    
    <div class="connection-panel">
      <div class="connection-status">
        <div class="status-indicator" id="statusIndicator"></div>
        <span id="connectionStatus">未连接</span>
      </div>
      
      <div class="room-controls">
        <input type="text" id="roomId" placeholder="输入房间号">
        <button class="btn-secondary" id="joinRoom">加入房间</button>
        <button class="btn-primary" id="createRoom">创建房间</button>
      </div>
      
      <button class="btn-primary" id="reset" style="width: 100%">重新开始</button>
    </div>
  </div>

  <script>
    class TicTacToeGame {
      constructor() {
        this.board = Array(9).fill(null);
        this.currentPlayer = 'X';
        this.isGameOver = false;
        this.peer = null;
        this.socket = null;
        this.roomId = null;
        this.isHost = false;
        
        this.initElements();
        this.initEventListeners();
        this.render();
      }
      
      initElements() {
        this.boardEl = document.getElementById('board');
        this.cells = Array.from(document.querySelectorAll('.cell'));
        this.statusIndicator = document.getElementById('statusIndicator');
        this.connectionStatus = document.getElementById('connectionStatus');
        this.roomIdInput = document.getElementById('roomId');
        this.joinBtn = document.getElementById('joinRoom');
        this.createBtn = document.getElementById('createRoom');
        this.resetBtn = document.getElementById('reset');
      }
      
      initEventListeners() {
        this.cells.forEach(cell => {
          cell.addEventListener('click', (e) => this.handleMove(e));
        });
        
        this.joinBtn.addEventListener('click', () => this.joinRoom());
        this.createBtn.addEventListener('click', () => this.createRoom());
        this.resetBtn.addEventListener('click', () => this.resetGame());
      }
      
      // 游戏逻辑
      handleMove(e) {
        const index = e.target.dataset.index;
        if (this.board[index] || this.isGameOver) return;
        
        this.board[index] = this.currentPlayer;
        this.render();
        
        if (this.checkWin(this.currentPlayer)) {
          this.isGameOver = true;
          alert(`玩家 ${this.currentPlayer} 获胜!`);
          return;
        }
        
        if (this.checkDraw()) {
          this.isGameOver = true;
          alert('平局!');
          return;
        }
        
        this.currentPlayer = this.currentPlayer === 'X' ? 'O' : 'X';
      }
      
      checkWin(player) {
        const winPatterns = [
          [0,1,2], [3,4,5], [6,7,8], // 行
          [0,3,6], [1,4,7], [2,5,8], // 列
          [0,4,8], [2,4,6] // 对角线
        ];
        
        return winPatterns.some(pattern => 
          pattern.every(index => this.board[index] === player)
        );
      }
      
      checkDraw() {
        return this.board.every(cell => cell !== null);
      }
      
      render() {
        this.cells.forEach((cell, index) => {
          cell.textContent = this.board[index] || '';
          cell.className = 'cell';
          if (this.board[index]) {
            cell.classList.add(this.board[index]);
          }
        });
      }
      
      // 网络连接部分
      async createRoom() {
        this.isHost = true;
        this.roomId = Math.random().toString(36).substr(2, 6).toUpperCase();
        this.roomIdInput.value = this.roomId;
        
        this.updateConnectionStatus('正在连接...', 'connecting');
        
        try {
          await this.initWebSocket();
          await this.initWebRTC(true);
          this.updateConnectionStatus('等待玩家加入...', 'connected');
        } catch (error) {
          console.error('创建房间失败:', error);
          this.updateConnectionStatus('连接失败', 'error');
        }
      }
      
      async joinRoom() {
        this.roomId = this.roomIdInput.value.trim();
        if (!this.roomId) return alert('请输入房间号');
        
        this.updateConnectionStatus('正在加入房间...', 'connecting');
        
        try {
          await this.initWebSocket();
          await this.initWebRTC(false);
          this.updateConnectionStatus('已连接到房间', 'connected');
        } catch (error) {
          console.error('加入房间失败:', error);
          this.updateConnectionStatus('连接失败', 'error');
        }
      }
      
      initWebSocket() {
        return new Promise((resolve, reject) => {
          const wsUrl = 'wss://hongyuwei.onrender.com';
          this.socket = new WebSocket(wsUrl);
          
          this.socket.onopen = () => {
            console.log('WebSocket连接已建立');
            resolve();
          };
          
          this.socket.onerror = (error) => {
            console.error('WebSocket错误:', error);
            reject(error);
          };
          
          this.socket.onmessage = (event) => {
            const message = JSON.parse(event.data);
            this.handleWebSocketMessage(message);
          };
        });
      }
      
      initWebRTC(initiator) {
        return new Promise((resolve) => {
          const iceServers = [
            { urls: 'stun:stun.l.google.com:19302' },
            { 
              urls: 'turn:numb.viagenie.ca',
              credential: 'muazkh',
              username: 'webrtc@live.com'
            }
          ];
          
          this.peer = new SimplePeer({
            initiator,
            trickle: true,
            config: { iceServers }
          });
          
          this.peer.on('signal', data => {
            this.socket.send(JSON.stringify({
              type: 'signal',
              roomId: this.roomId,
              data
            }));
          });
          
          this.peer.on('connect', () => {
            console.log('WebRTC连接已建立');
            resolve();
          });
          
          this.peer.on('data', data => {
            const message = JSON.parse(data);
            this.handleDataMessage(message);
          });
          
          this.peer.on('error', error => {
            console.error('WebRTC错误:', error);
          });
        });
      }
      
      handleWebSocketMessage(message) {
        if (message.type === 'signal' && this.peer) {
          this.peer.signal(message.data);
        }
      }
      
      handleDataMessage(message) {
        // 处理游戏数据消息
        console.log('收到数据:', message);
      }
      
      updateConnectionStatus(text, status) {
        this.connectionStatus.textContent = text;
        this.statusIndicator.className = 'status-indicator';
        
        if (status === 'connected') {
          this.statusIndicator.classList.add('connected');
        }
      }
      
      resetGame() {
        this.board = Array(9).fill(null);
        this.currentPlayer = 'X';
        this.isGameOver = false;
        this.render();
      }
    }

    // 初始化游戏
    document.addEventListener('DOMContentLoaded', () => {
      new TicTacToeGame();
    });
  </script>
  
  <!-- 使用最新版SimplePeer -->
  <script src="https://cdn.jsdelivr.net/npm/simple-peer@9.11.1/simplepeer.min.js"></script>
</body>
</html>