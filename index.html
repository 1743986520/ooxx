<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebRTC 井字棋</title>
  <style>
    /* 原有的 CSS 保持不變，僅添加房間號輸入框的樣式 */
    .room-controls {
      display: flex;
      gap: 10px;
      justify-content: center;
      flex-wrap: wrap;
      margin-bottom: 15px;
    }
    .room-input {
      max-width: 150px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>WebRTC 井字棋</h1>
    
    <div class="mode-group">
      <button class="mode-btn active" data-mode="hotseat">本地雙人</button>
      <button class="mode-btn" data-mode="pve">單人模式</button>
      <button class="mode-btn" data-mode="online">線上對戰</button>
    </div>
    
    <div class="player-indicator">
      <div class="player X">玩家 X</div>
      <div class="player O">玩家 O</div>
    </div>
    
    <div class="board" id="board"></div>
    
    <div class="status" id="status">玩家 X 回合</div>
    
    <div class="connection-panel" id="connectionPanel" style="display: none;">
      <div class="connection-box">
        <h3>線上對戰</h3>
        <div class="connection-status">
          <div class="status-indicator" id="statusIndicator"></div>
          <span id="connectionStatus">未連接</span>
        </div>
        
        <div class="room-controls">
          <input type="text" id="roomId" class="room-input" placeholder="輸入房間號">
          <button id="joinRoom" class="secondary">加入房間</button>
          <button id="createRoom" class="secondary">創建房間</button>
        </div>
        
        <div class="instructions">
          <strong>線上對戰操作步驟：</strong>
          <ol>
            <li>點擊“創建房間”生成一個房間號並分享給對方</li>
            <li>或輸入對方分享的房間號，點擊“加入房間”</li>
            <li>等待對方加入後開始遊戲</li>
          </ol>
        </div>
      </div>
    </div>
    
    <button id="reset">重新開始</button>
  </div>

  <!-- 引入 SimplePeer -->
  <script src="https://cdn.jsdelivr.net/npm/simple-peer@9.11.1/simplepeer.min.js"></script>
  <!-- 引入 WebSocket 客戶端 -->
  <script>
    // 遊戲狀態管理
    const game = {
      board: Array(9).fill(null),
      currentPlayer: "X",
      isGameOver: false,
      mode: "hotseat",
      peer: null,
      isHost: false,
      playerRole: "X",
      dataChannel: null,
      socket: null,

      // 初始化遊戲
      init() {
        this.render();
        this.bindEvents();
        this.updatePlayerIndicator();
        this.initWebSocket();
      },

      // 渲染棋盤
      render() {
        const boardEl = document.getElementById("board");
        boardEl.innerHTML = "";
        
        this.board.forEach((cell, index) => {
          const cellEl = document.createElement("div");
          cellEl.className = `cell ${cell === "X" ? "X" : cell === "O" ? "O" : ""}`;
          cellEl.dataset.index = index;
          cellEl.textContent = cell || "";
          
          if (!this.isGameOver && 
              (this.mode === "hotseat" || 
               (this.mode === "pve" && this.currentPlayer === "X") ||
               (this.mode === "online" && this.currentPlayer === this.playerRole))
          ) {
            cellEl.addEventListener("click", (e) => this.handlePlayerMove(e, index));
          }
          
          boardEl.appendChild(cellEl);
        });
        
        const statusEl = document.getElementById("status");
        statusEl.className = "status";
        
        if (this.isGameOver) {
          const winner = this.getWinner();
          if (winner) {
            statusEl.textContent = `玩家 ${winner} 獲勝！`;
            statusEl.classList.add("win");
          } else {
            statusEl.textContent = "平局！";
            statusEl.classList.add("draw");
          }
        } else {
          statusEl.textContent = `玩家 ${this.currentPlayer} 回合`;
        }
      },
      
      updatePlayerIndicator() {
        document.querySelectorAll(".player").forEach(playerEl => {
          playerEl.classList.remove("active");
          if (playerEl.textContent.includes(this.currentPlayer)) {
            playerEl.classList.add("active");
          }
        });
      },

      handlePlayerMove(e, index) {
        if (this.board[index] !== null || this.isGameOver) return;
        
        this.board[index] = this.currentPlayer;
        
        if (this.mode === "online" && this.dataChannel && this.dataChannel.readyState === "open") {
          this.sendNetworkMessage({
            type: "move",
            index: index,
            player: this.currentPlayer
          });
        }
        
        this.render();
        this.updatePlayerIndicator();
        
        if (this.checkWin(this.currentPlayer)) {
          this.isGameOver = true;
          this.render();
          return;
        }
        
        if (this.checkDraw()) {
          this.isGameOver = true;
          this.render();
          return;
        }
        
        if (this.mode === "hotseat" || this.mode === "online") {
          this.currentPlayer = this.currentPlayer === "X" ? "O" : "X";
          this.updatePlayerIndicator();
        } else if (this.mode === "pve") {
          this.currentPlayer = "O";
          this.updatePlayerIndicator();
          setTimeout(() => this.aiMove(), 500);
        }
      },

      aiMove() {
        if (this.isGameOver) return;
        
        const winPos = this.findWinOrBlock("O");
        if (winPos !== -1) {
          this.board[winPos] = "O";
          this.render();
          this.checkGameEnd("O");
          return;
        }
        
        const blockPos = this.findWinOrBlock("X");
        if (blockPos !== -1) {
          this.board[blockPos] = "O";
          this.render();
          this.checkGameEnd("O");
          return;
        }
        
        if (this.board[4] === null) {
          this.board[4] = "O";
          this.render();
          this.checkGameEnd("O");
          return;
        }
        
        const corners = [0, 2, 6, 8].filter(i => this.board[i] === null);
        if (corners.length > 0) {
          const corner = corners[Math.floor(Math.random() * corners.length)];
          this.board[corner] = "O";
          this.render();
          this.checkGameEnd("O");
          return;
        }
        
        const edges = [1, 3, 5, 7].filter(i => this.board[i] === null);
        if (edges.length > 0) {
          const edge = edges[Math.floor(Math.random() * edges.length)];
          this.board[edge] = "O";
          this.render();
          this.checkGameEnd("O");
        }
      },

      checkGameEnd(aiPlayer) {
        if (this.checkWin(aiPlayer)) {
          this.isGameOver = true;
          this.render();
        } else if (this.checkDraw()) {
          this.isGameOver = true;
          this.render();
        } else {
          this.currentPlayer = "X";
          this.updatePlayerIndicator();
          this.render();
        }
      },

      checkWin(player) {
        const winPatterns = [
          [0,1,2], [3,4,5], [6,7,8],
          [0,3,6], [1,4,7], [2,5,8],
          [0,4,8], [2,4,6]
        ];
        return winPatterns.some(pattern => 
          pattern.every(index => this.board[index] === player)
        );
      },

      checkDraw() {
        return this.board.every(cell => cell !== null);
      },

      findWinOrBlock(player) {
        const winPatterns = [
          [0,1,2], [3,4,5], [6,7,8],
          [0,3,6], [1,4,7], [2,5,8],
          [0,4,8], [2,4,6]
        ];
        
        for (const pattern of winPatterns) {
          const [a, b, c] = pattern;
          if (
            this.board[a] === player && 
            this.board[b] === player && 
            this.board[c] === null
          ) return c;
          if (
            this.board[a] === player && 
            this.board[c] === player && 
            this.board[b] === null
          ) return b;
          if (
            this.board[b] === player && 
            this.board[c] === player && 
            this.board[a] === null
          ) return a;
        }
        return -1;
      },

      getWinner() {
        if (this.checkWin("X")) return "X";
        if (this.checkWin("O")) return "O";
        return null;
      },

      reset() {
        this.board = Array(9).fill(null);
        this.currentPlayer = "X";
        this.isGameOver = false;
        
        if (this.mode === "online" && this.dataChannel && this.dataChannel.readyState === "open") {
          this.sendNetworkMessage({ type: "reset" });
          if (this.isHost) {
            this.sendNetworkMessage({ 
              type: "role",
              role: this.playerRole
            });
          }
        }
        
        this.updatePlayerIndicator();
        this.render();
      },

      switchMode(mode) {
        this.mode = mode;
        document.querySelectorAll(".mode-btn").forEach(btn => {
          btn.classList.remove("active");
          if (btn.dataset.mode === mode) {
            btn.classList.add("active");
          }
        });
        
        const connectionPanel = document.getElementById("connectionPanel");
        if (mode === "online") {
          connectionPanel.style.display = "block";
          this.resetConnectionUI();
        } else {
          connectionPanel.style.display = "none";
          if (this.peer) {
            this.peer.destroy();
            this.peer = null;
            this.dataChannel = null;
          }
          if (this.socket) {
            this.socket.close();
            this.socket = null;
          }
          this.updateConnectionStatus("未連接", "disconnected");
        }
        
        this.reset();
      },

      resetConnectionUI() {
        document.getElementById("roomId").value = "";
        this.updateConnectionStatus("未連接", "disconnected");
      },

      initWebSocket() {
        document.getElementById("createRoom").addEventListener("click", () => {
          this.createRoom();
        });
        
        document.getElementById("joinRoom").addEventListener("click", () => {
          this.joinRoom();
        });
      },

      createRoom() {
        this.isHost = true;
        this.playerRole = "X";
        this.resetConnectionUI();
        
        // 生成隨機房間號
        const roomId = Math.random().toString(36).substr(2, 6).toUpperCase();
        document.getElementById("roomId").value = roomId;
        
        // 連接到 WebSocket 服務器
        this.socket = new WebSocket("wss://your-websocket-server.com"); // 替換為你的 WebSocket 服務器地址
        this.socket.onopen = () => {
          this.socket.send(JSON.stringify({ type: "create", roomId }));
          this.updateConnectionStatus("等待玩家加入房間 " + roomId, "connecting");
          this.setupPeer(true);
        };
        
        this.socket.onmessage = (event) => {
          const msg = JSON.parse(event.data);
          this.handleSocketMessage(msg);
        };
        
        this.socket.onclose = () => {
          this.updateConnectionStatus("服務器連接關閉", "disconnected");
        };
        
        this.socket.onerror = (err) => {
          console.error("WebSocket 錯誤:", err);
          this.updateConnectionStatus("服務器連接錯誤", "disconnected");
        };
      },

      joinRoom() {
        this.isHost = false;
        this.playerRole = "O";
        const roomId = document.getElementById("roomId").value.trim();
        if (!roomId) {
          alert("請輸入房間號");
          return;
        }
        
        this.socket = new WebSocket("wss://your-websocket-server.com"); // 替換為你的 WebSocket 服務器地址
        this.socket.onopen = () => {
          this.socket.send(JSON.stringify({ type: "join", roomId }));
          this.updateConnectionStatus("正在加入房間 " + roomId, "connecting");
          this.setupPeer(false);
        };
        
        this.socket.onmessage = (event) => {
          const msg = JSON.parse(event.data);
          this.handleSocketMessage(msg);
        };
        
        this.socket.onclose = () => {
          this.updateConnectionStatus("服務器連接關閉", "disconnected");
        };
        
        this.socket.onerror = (err) => {
          console.error("WebSocket 錯誤:", err);
          this.updateConnectionStatus("服務器連接錯誤", "disconnected");
        };
      },

      setupPeer(initiator) {
        this.peer = new SimplePeer({
          initiator,
          trickle: false,
          config: {
            iceServers: [
              { urls: "stun:stun.l.google.com:19302" },
              { urls: "stun:global.stun.twilio.com:3478?transport=udp" }
            ]
          }
        });
        
        this.peer.on("signal", (data) => {
          this.socket.send(JSON.stringify({
            type: "signal",
            roomId: document.getElementById("roomId").value,
            data
          }));
        });
        
        this.peer.on("connect", () => {
          this.dataChannel = this.peer;
          this.updateConnectionStatus("已連接到對方玩家", "connected");
          this.reset();
          
          if (this.isHost) {
            this.sendNetworkMessage({ 
              type: "role",
              role: this.playerRole
            });
          }
        });
        
        this.peer.on("data", (data) => {
          try {
            const msg = JSON.parse(data);
            this.handleNetworkMessage(msg);
          } catch (e) {
            console.error("數據解析錯誤:", e);
          }
        });
        
        this.peer.on("close", () => {
          this.updateConnectionStatus("連接已關閉", "disconnected");
          this.dataChannel = null;
        });
        
        this.peer.on("error", (err) => {
          console.error("WebRTC 錯誤:", err);
          alert("連接錯誤: " + err.message);
          this.updateConnectionStatus("連接錯誤", "disconnected");
        });
      },

      handleSocketMessage(msg) {
        switch (msg.type) {
          case "roomCreated":
            alert("房間創建成功，房間號: " + msg.roomId + "\n請分享給對方");
            break;
          case "roomJoined":
            this.updateConnectionStatus("房間已加入，等待連接...", "connecting");
            break;
          case "signal":
            this.peer.signal(msg.data);
            break;
          case "error":
            alert("錯誤: " + msg.message);
            this.updateConnectionStatus("連接錯誤", "disconnected");
            break;
        }
      },

      handleNetworkMessage(msg) {
        switch (msg.type) {
          case "move":
            this.board[msg.index] = msg.player;
            this.currentPlayer = this.currentPlayer === "X" ? "O" : "X";
            this.render();
            this.updatePlayerIndicator();
            break;
          case "reset":
            this.reset();
            break;
          case "role":
            this.playerRole = msg.role;
            break;
        }
      },

      sendNetworkMessage(msg) {
        if (this.dataChannel && this.dataChannel.readyState === "open") {
          try {
            this.dataChannel.send(JSON.stringify(msg));
          } catch (e) {
            console.error("發送消息失敗:", e);
          }
        }
      },

      updateConnectionStatus(text, status) {
        document.getElementById("connectionStatus").textContent = text;
        const indicator = document.getElementById("statusIndicator");
        indicator.className = "status-indicator";
        
        if (status === "connecting") {
          indicator.classList.add("connecting");
        } else if (status === "connected") {
          indicator.classList.add("connected");
        }
      },

      bindEvents() {
        document.getElementById("reset").addEventListener("click", () => this.reset());
        
        document.querySelectorAll(".mode-btn").forEach(btn => {
          btn.addEventListener("click", () => this.switchMode(btn.dataset.mode));
        });
      }
    };
    
    document.addEventListener("DOMContentLoaded", () => {
      game.init();
    });
  </script>
</body>
</html>